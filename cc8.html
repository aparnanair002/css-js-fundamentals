<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Bugs and Errors</title>
    <link rel="stylesheet" href="styles.css" />
  </head>
  <body>
    <div class="sidebar">
      <h2>Contents</h2>
      <ul>
        <a href="./c1.html"><div class="gridded">Chap 1</div></a>
        <a href="./c2.html"><div class="gridded">Chap 2</div></a>
        <a href="./c3.html"><div class="gridded">Chap 3</div></a>
        <a href="./c4.html"> <div class="gridded">Chap 4</div></a>
        <a href="./c5.html"><div class="gridded">Chap 5</div></a>
        <a href="./c6.html"> <div class="gridded">Chap 6</div></a>
        <a href="./c7.html"><div class="gridded">Chap 7</div></a>
        <a href="./cc8.html"><div class="gridded">Chap 8</div></a>
        <a href="./c9.html"><div class="gridded">Chap 9</div></a>
        <a href="./c10.html"><div class="gridded">Chap 10</div></a>
        <a href="./c11.html"><div class="gridded">Chap 11</div></a>
        <a href="./c12.html"><div class="gridded">Chap 12</div></a>
        <a href="./c13.html"><div class="gridded">Chap 13</div></a>
        <a href="./c14.html"><div class="gridded">Chap 14</div></a>
        <a href="./c15.html"><div class="gridded">Chap 15</div></a>

        <a href="./c17.html"><div class="gridded">Chap 17</div></a>
        <a href="./c18.html"><div class="gridded">Chap 18</div></a>
        <a href="./c20.html"><div class="gridded">Chap 20</div></a>
      </ul>
    </div>
    <div class="content">
      <h1>Bugs and Errors</h1>

      <p>
        <em
          >Debugging is twice as hard as writing the code in the first place.
          Therefore, if you write the code as cleverly as possible, you are, by
          definition, not smart enough to debug it.</em
        ><br />
        <strong
          >— Brian Kernighan and P.J. Plauger, The Elements of Programming
          Style</strong
        >
      </p>

      <p>Illustration showing various insects and a centipede</p>

      <p>
        Flaws in computer programs are usually called bugs. It makes programmers
        feel good to imagine them as little things that just happen to crawl
        into our work. In reality, of course, we put them there ourselves.
      </p>

      <p>
        If a program is crystallized thought, we can roughly categorize bugs
        into those caused by the thoughts being confused and those caused by
        mistakes introduced while converting a thought to code. The former type
        is generally harder to diagnose and fix than the latter.
      </p>

      <h2>Language</h2>
      <p>
        Many mistakes could be pointed out to us automatically by the computer
        if it knew enough about what we’re trying to do. But here, JavaScript’s
        looseness is a hindrance...
      </p>

      <pre><code>function canYouSpotTheProblem() {
  "use strict";
  for (counter = 0; counter &lt; 10; counter++) {
    console.log("Happy happy");
  }
}

canYouSpotTheProblem();
// → ReferenceError: counter is not defined
</code></pre>

      <p>...Code inside classes and modules is automatically strict...</p>

      <h2>Strict mode</h2>

      <p>JavaScript can be made a little stricter by enabling strict mode...</p>

      <pre><code>"use strict";
function Person(name) { this.name = name; }
let ferdinand = Person("Ferdinand"); // forgot new
// → TypeError: Cannot set property 'name' of undefined
</code></pre>

      <h2>Types</h2>
      <p>
        Some languages want to know the types of all your bindings and
        expressions before even running a program...
      </p>

      <pre><code>// (graph: Object, from: string, to: string) =&gt; string[]
function findRoute(graph, from, to) {
  // ...
}
</code></pre>

      <h2>Testing</h2>
      <p>
        If the language is not going to do much to help us find mistakes, we’ll
        have to find them the hard way...
      </p>

      <pre><code>function test(label, body) {
  if (!body()) console.log(`Failed: ${label}`);
}

test("convert Latin text to uppercase", () =&gt; {
  return "hello".toUpperCase() == "HELLO";
});
</code></pre>

      <h2>Debugging</h2>
      <p>
        Once you notice there is something wrong with your program because it
        misbehaves or produces errors...
      </p>

      <pre><code>function numberToString(n, base = 10) {
  let result = "", sign = "";
  if (n &lt; 0) {
    sign = "-";
    n = -n;
  }
  do {
    result = String(n % base) + result;
    n /= base;
  } while (n &gt; 0);
  return sign + result;
}
console.log(numberToString(13, 10));
</code></pre>

      <h2>Error propagation</h2>
      <p>Not all problems can be prevented by the programmer...</p>

      <pre><code>function promptNumber(question) {
  let result = Number(prompt(question));
  if (Number.isNaN(result)) return null;
  else return result;
}
</code></pre>

      <h2>Exceptions</h2>

      <pre><code>function promptDirection(question) {
  let result = prompt(question);
  if (result.toLowerCase() == "left") return "L";
  if (result.toLowerCase() == "right") return "R";
  throw new Error("Invalid direction: " + result);
}

try {
  console.log("You see", look());
} catch (error) {
  console.log("Something went wrong: " + error);
}
</code></pre>

      <h2>Cleaning up after exceptions</h2>
      <p>A finally block says “no matter what happens, run this code...”</p>

      <pre><code>function transfer(from, amount) {
  if (accounts[from] &lt; amount) return;
  let progress = 0;
  try {
    accounts[from] -= amount;
    progress = 1;
    accounts[getAccount()] += amount;
    progress = 2;
  } finally {
    if (progress == 1) {
      accounts[from] += amount;
    }
  }
}
</code></pre>

      <h2>Selective catching</h2>
      <p>
        When an exception makes it all the way to the bottom of the stack...
      </p>
    </div>

    <h2>Excercises</h2>
    <section>
      Exercises
Retry
Say you have a function primitiveMultiply that in 20 percent of cases multiplies two numbers and in the other 80 percent of cases raises an exception of type MultiplicatorUnitFailure. Write a function that wraps this clunky function and just keeps trying until a call succeeds, after which it returns the result.

Make sure you handle only the exceptions you are trying to handle.

class MultiplicatorUnitFailure extends Error {}

function primitiveMultiply(a, b) {
  if (Math.random() < 0.2) {
    return a * b;
  } else {
    throw new MultiplicatorUnitFailure("Klunk");
  }
}

function reliableMultiply(a, b) {
  // Your code here.
}

console.log(reliableMultiply(8, 8));
// → 64
Display hints...
The locked box
Consider the following (rather contrived) object:

const box = new class {
  locked = true;
  #content = [];

  unlock() { this.locked = false; }
  lock() { this.locked = true;  }
  get content() {
    if (this.locked) throw new Error("Locked!");
    return this.#content;
  }
};
It is a box with a lock. There is an array in the box, but you can get at it only when the box is unlocked.

Write a function called withBoxUnlocked that takes a function value as argument, unlocks the box, runs the function, and then ensures that the box is locked again before returning, regardless of whether the argument function returned normally or threw an exception.

const box = new class {
  locked = true;
  #content = [];

  unlock() { this.locked = false; }
  lock() { this.locked = true;  }
  get content() {
    if (this.locked) throw new Error("Locked!");
    return this.#content;
  }
};

function withBoxUnlocked(body) {
  // Your code here.
}

withBoxUnlocked(() => {
  box.content.push("gold piece");
});

try {
  withBoxUnlocked(() => {
    throw new Error("Pirates on the horizon! Abort!");
  });
} catch (e) {
  console.log("Error raised: " + e);
}
console.log(box.locked);
// → true
    </section>
  </body>
</html>
