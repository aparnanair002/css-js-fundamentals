<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Abstract Data Types & Prototypes Summary</title>
    <link rel="stylesheet" href="styles.css" />

</head>
<body>
  <div class="sidebar">
  <h2>Contents</h2>
  <ul>
      <a href="./c1.html"><div class="gridded">Chap 1</div></a>
      <a href="./c2.html"><div class="gridded">Chap 2</div></a>
       <a href="./c3.html"><div class="gridded">Chap 3</div></a>
      <a href="./c4.html"> <div class="gridded">Chap 4</div></a>
       <a href="./c5.html"><div class="gridded">Chap 5</div></a>
         <a href="./c6.html"> <div class="gridded">Chap 6</div></a>
       <a href="./c7.html"><div class="gridded">Chap 7</div></a>
       <a href="./cc8.html"><div class="gridded">Chap 8</div></a>
              <a href="./c9.html"><div class="gridded">Chap 9</div></a>
        <a href="./c10.html"><div class="gridded">Chap 10</div></a>
        <a href="./c11.html"><div class="gridded">Chap 11</div></a>
                <a href="./c12.html"><div class="gridded">Chap 12</div></a>
      <a href="./c13.html"><div class="gridded">Chap 13</div></a>
        <a href="./c14.html"><div class="gridded">Chap 14</div></a>
          <a href="./c15.html"><div class="gridded">Chap 15</div></a>

          <a href="./c17.html"><div class="gridded">Chap 17</div></a>
          <a href="./c18.html"><div class="gridded">Chap 18</div></a>
          <a href="./c20.html"><div class="gridded">Chap 20</div></a>





    </ul>
  </div>
<h1>Abstract Data Types, Prototypes & Classes â€” Summary</h1>

<h2>1. Abstract Data Types (ADTs)</h2>
<p>
  ðŸ”¹ Queue ADT

enqueue

dequeue

front

isEmpty

ðŸ”¹ Queue Data Structure

Can be implemented using:

arrays

linked lists

two stacks

circular buffer
  An abstract data type hides internal complexity and provides only specific operations. 
  JavaScriptâ€™s objects, arrays, strings, and numbers behave like ADTs.
</p>

<h2>2. Methods & <code>this</code></h2>
<p>
  A method is a function stored in an object. Calling <code>obj.method()</code> sets <code>this</code> to <code>obj</code>.
</p>

<pre><code>let rabbit = { type: "white", speak };
rabbit.speak("Hello!");
</code></pre>

<p><b>The <code>call</code> method:</b></p>
<pre><code>speak.call(rabbit, "Hi!");
</code></pre>

<p><b>Arrow functions:</b> they do not have their own <code>this</code>.</p>

<h2>3. Prototypes</h2>
<p>
  Every JavaScript object has a prototype it inherits properties from.
</p>

<pre><code>let empty = {};
empty.toString(); // inherited
</code></pre>

<p>You can create objects with a custom prototype:</p>

<pre><code>let blackRabbit = Object.create(protoRabbit);
</code></pre>

<h2>4. Classes</h2>
<p>Classes are cleaner syntax around prototypes:</p>

<pre><code>class Rabbit {
  constructor(type) {
    this.type = type;
  }
  speak(line) {
    console.log(`The ${this.type} rabbit says ${line}`);
  }
}
</code></pre>

<h2>5. Private Properties</h2>
<pre><code>class Secret {
  #secret = "hidden";
  reveal() { return this.#secret; }
}
</code></pre>

<h2>6. Overriding Properties</h2>
<p>Object properties override prototype properties:</p>

<pre><code>Rabbit.prototype.teeth = "small";
killerRabbit.teeth = "sharp and long";
</code></pre>

<h2>7. Maps</h2>
<p>Unlike plain objects, <code>Map</code> allows any keys and avoids prototype issues:</p>

<pre><code>let ages = new Map();
ages.set("Boris", 39);
</code></pre>

<h2>8. Polymorphism</h2>
<p>Objects override shared methods like <code>toString</code> to define custom behavior:</p>

<pre><code>Rabbit.prototype.toString = function() {
  return `a ${this.type} rabbit`;
};
</code></pre>

<h2>9. Getters, Setters & Static Methods</h2>

<pre><code>get size() { return this.items.length; }
set fahrenheit(v) { this.celsius = (v - 32) / 1.8; }

static fromFahrenheit(v) { ... }
</code></pre>

<h2>10. Symbols</h2>
<p>Symbols create unique property keys:</p>

<pre><code>let sym = Symbol("id");
obj[sym] = 123;
</code></pre>

<h2>11. Iteration Protocol</h2>
<p>
  For an object to work with <code>for...of</code>, it must implement 
  <code>Symbol.iterator</code>.
</p>

<pre><code>"OK"[Symbol.iterator] // returns iterator
</code></pre>


<h2>12. Summary</h2>
<p>
  This chapter covered abstract data types, methods, prototypes, classes, private properties, maps, polymorphism, getters/setters, static methods, symbols, and the iteration protocol.
  Objects group data + methods<br>

Abstract data types expose an interface, hide internals
<br>
Prototypes let objects share behavior
<br>
Classes are a cleaner way to work with prototypes
<br>
Private fields (#) hide data
<br>
Maps are safer than using plain objects
<br>
Polymorphism lets different objects work with the same code
<br>
Getters/Setters create dynamic properties
</p>
<h2>Excercise</h2>
<section>
  A vector type
Write a class Vec that represents a vector in two-dimensional space. It takes x and y parameters (numbers), that it saves to properties of the same name.

Give the Vec prototype two methods, plus and minus, that take another vector as a parameter and return a new vector that has the sum or difference of the two vectorsâ€™ (this and the parameter) x and y values.

Add a getter property length to the prototype that computes the length of the vectorâ€”that is, the distance of the point (x, y) from the origin (0, 0).

// Your code here.

console.log(new Vec(1, 2).plus(new Vec(2, 3)));
// â†’ Vec{x: 3, y: 5}
console.log(new Vec(1, 2).minus(new Vec(2, 3)));
// â†’ Vec{x: -1, y: -1}
console.log(new Vec(3, 4).length);
// â†’ 5
Display hints...
Groups
The standard JavaScript environment provides another data structure called Set. Like an instance of Map, a set holds a collection of values. Unlike Map, it does not associate other values with thoseâ€”it just tracks which values are part of the set. A value can be part of a set only onceâ€”adding it again doesnâ€™t have any effect.

Write a class called Group (since Set is already taken). Like Set, it has add, delete, and has methods. Its constructor creates an empty group, add adds a value to the group (but only if it isnâ€™t already a member), delete removes its argument from the group (if it was a member), and has returns a Boolean value indicating whether its argument is a member of the group.

Use the === operator, or something equivalent such as indexOf, to determine whether two values are the same.

Give the class a static from method that takes an iterable object as its argument and creates a group that contains all the values produced by iterating over it.

class Group {
  // Your code here.
}

let group = Group.from([10, 20]);
console.log(group.has(10));
// â†’ true
console.log(group.has(30));
// â†’ false
group.add(10);
group.delete(10);
console.log(group.has(10));
// â†’ false
Display hints...
Iterable groups
Make the Group class from the previous exercise iterable. Refer to the section about the iterator interface earlier in the chapter if you arenâ€™t clear on the exact form of the interface anymore.

If you used an array to represent the groupâ€™s members, donâ€™t just return the iterator created by calling the Symbol.iterator method on the array. That would work, but it defeats the purpose of this exercise.

It is okay if your iterator behaves strangely when the group is modified during iteration.

// Your code here (and the code from the previous exercise)

for (let value of Group.from(["a", "b", "c"])) {
  console.log(value);
}
// â†’ a
// â†’ b
// â†’ c
</section>
</body>
</html>
