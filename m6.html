<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Module 5</title>
    <link href="style.css" rel="stylesheet" />
  </head>
  <body>
    <div class="sidebar">
      <div class="module-item" id="mod1">
        <div class="module">
          <div class="sidebar-content">Home</div>
        </div>
      </div>
    </div>
    <div class="sidebody">
     <div class="ap">Text Rendering</div>
     <div class="notes">
        While comparing chrome and safari, it was found that Chrome tucks the commas closer to the preceding word than Safari.
         the reason that the letter placement is slightly different between browsers is that the browsers implement different <b>kerning algorithms.</b>
         Using CSS, we can opt to disable kerning altogether with font-kerning: none, but we aren't offered any fine-grained control. letter-spacing, the property that allows us to increase/decrease the space between individual characters, acts as a "kerning multiplier"
     <textarea name="" id=""> -webkit-font-smoothing property.

This property allows us to switch which aliasing algorithm the browser uses. But, tragically, it only works on macOS, and only in Chrome/Safari/Edge (not Firefox).</textarea>
     <div class="notes">WebKit is a browser rendering engine developed by Apple*</div>
     To summerize,
     <textarea name="" id="">
       <b> Kerning (character spacing)</b>

Chrome and Safari render text slightly differently.

Commas, letters, and spacing vary because each browser uses its own kerning algorithms.

Designers can tweak kerning manually with CSS (font-kerning: none + letter-spacing), but it’s tricky.

<b>Text rasterization & anti-aliasing</b>

Fonts are vectors, so browsers must “rasterize” them into pixels.

Anti-aliasing smooths edges, but each OS/browser has its own approach.

Windows uses subpixel rendering with colored edges (ClearType), macOS uses grayscale antialiasing.

<b>Font smoothing in CSS</b>

-webkit-font-smoothing (macOS only) lets you toggle antialiasing methods, but it’s limited.

Since macOS Mojave, Apple disabled subpixel antialiasing on Retina screens (too many tiny pixels, causes muddiness).

Firefox on macOS uses -moz-osx-font-smoothing, but it rarely makes a difference.

Windows browsers don’t expose smoothing controls via CSS.

<b>Accessibility debate</b>

Subpixel antialiasing was once considered crisper and better for readability (2012 article), but on modern high-DPI displays, grayscale antialiasing usually works better.

Browser rendering engines

Safari uses WebKit.

Chrome/Edge use Blink, a fork of WebKit.

That’s why many browsers still support -webkit- prefixed CSS.
     </textarea>
     <div class="ap">Text overflow</div>
     <div class="notes">With the overflow-wrap property, we can linewrap longer words/strings:</div>
     <textarea name="" id="">
        <style>
  p {
    overflow-wrap: break-word;
    hyphens: auto;
    
    /* Prefix for Safari */
    -webkit-hyphens: auto;
  }
</style>
     </textarea>
     <div class="notes">
      Handling long unbreakable words/URLs

If no soft wrap opportunities exist, text can overflow.

Fix with overflow-wrap: break-word (or word-wrap in IE).

Hyphenation

hyphens: auto allows breaking words with hyphens.

Works best with overflow-wrap: break-word.

Requires <html lang="...">. Behavior varies by browser.

Ellipsis for overflow

text-overflow: ellipsis + overflow: hidden can truncate text with “…”.

Single-line ellipsis requires white-space: nowrap.

Multi-line ellipsis can be done with -webkit-line-clamp, though setup is verbose and buggy with flex/grid unless wrapped.

Best practices & cautions

Ellipsis should be used carefully (don’t hide critical info).

Hyphenation and truncation improve readability but depend on browser support.

Always balance usability and design when concealing text.

     </div>
        </div>
<div class="ap">Print style layout</div>
<div class="notes">
  .wrapper {
  column-count: 2;
  column-gap: 150px;
  max-width: 64rem;
  margin: 32px auto;
  border: 2px solid hsl(35deg 10% 40%);
  padding: 50px;
  background: linear-gradient(
    to right,
    hsl(35deg, 30%, 90%),
    hsl(35deg, 30%, 90%) 47%,
    hsl(35deg, 30%, 70%) 49.5%,
    hsl(35deg, 20%, 50%) 50%,
    hsl(35deg, 30%, 70%) 50.5%,
    hsl(35deg, 30%, 90%) 53%,
    hsl(35deg, 30%, 90%)
  );
}

h2 {
  font-size: 2rem;
  margin-bottom: 2em;
}

p {
  text-align: justify;
}

p:first-of-type::first-letter {
  font-size: 3em;
  float: left;
  line-height: 1em;
  margin-right: 0.2em;
}

p:not(:first-of-type) {
  text-indent: 2em;
}

* {
  font-family: 'Merriweather', serif;
}
</div>
<div class="notes">
  column layout
  break-inside: avoid; //prevents an element from being split across multiple columns, pages, or regions.
  floats
  floats:left //The element is removed from the normal document flow and positioned to the left of its containing element. Other content will flow around it on the right side.
  Indentation
  <textarea name="" id="">
      p::first-letter {
    margin-left: 2rem;
  }
  p {
    text-indent: 2rem;
  }
  </textarea>
  Justified alignment
  <textarea name="" id="">
     p {
    text-align: justify;
    padding: 16px;
  }
  </textarea>
  p:first-of-type::first-letter {
  initial-letter: 2; /* Makes the first letter span 2 lines in height */
}
Explanation:
p:first-of-type → selects the first <p> inside a parent.

::first-letter → targets the very first letter of that paragraph.

initial-letter: 2; → asks the browser to render that first letter as a “drop cap” spanning 2 lines high
</div>
    </div>
    </body>
    </html