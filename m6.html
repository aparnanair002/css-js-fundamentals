<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Module 5</title>
    <link href="style.css" rel="stylesheet" />
  </head>
  <body>
    <div class="sidebar">
      <div class="module-item" id="mod1">
        <div class="module">
          <div class="sidebar-content">Home</div>
        </div>
      </div>
    </div>
    <div class="sidebody">
     <div class="ap">Text Rendering</div>
     <div class="notes">
        While comparing chrome and safari, it was found that Chrome tucks the commas closer to the preceding word than Safari.
         the reason that the letter placement is slightly different between browsers is that the browsers implement different <b>kerning algorithms.</b>
         Using CSS, we can opt to disable kerning altogether with font-kerning: none, but we aren't offered any fine-grained control. letter-spacing, the property that allows us to increase/decrease the space between individual characters, acts as a "kerning multiplier"
     <textarea name="" id=""> -webkit-font-smoothing property.

This property allows us to switch which aliasing algorithm the browser uses. But, tragically, it only works on macOS, and only in Chrome/Safari/Edge (not Firefox).</textarea>
     <div class="notes">WebKit is a browser rendering engine developed by Apple*</div>
     To summerize,
     <textarea name="" id="">
       <b> Kerning (character spacing)</b>

Chrome and Safari render text slightly differently.

Commas, letters, and spacing vary because each browser uses its own kerning algorithms.

Designers can tweak kerning manually with CSS (font-kerning: none + letter-spacing), but it’s tricky.

<b>Text rasterization & anti-aliasing</b>

Fonts are vectors, so browsers must “rasterize” them into pixels.

Anti-aliasing smooths edges, but each OS/browser has its own approach.

Windows uses subpixel rendering with colored edges (ClearType), macOS uses grayscale antialiasing.

<b>Font smoothing in CSS</b>

-webkit-font-smoothing (macOS only) lets you toggle antialiasing methods, but it’s limited.

Since macOS Mojave, Apple disabled subpixel antialiasing on Retina screens (too many tiny pixels, causes muddiness).

Firefox on macOS uses -moz-osx-font-smoothing, but it rarely makes a difference.

Windows browsers don’t expose smoothing controls via CSS.

<b>Accessibility debate</b>

Subpixel antialiasing was once considered crisper and better for readability (2012 article), but on modern high-DPI displays, grayscale antialiasing usually works better.

Browser rendering engines

Safari uses WebKit.

Chrome/Edge use Blink, a fork of WebKit.

That’s why many browsers still support -webkit- prefixed CSS.
     </textarea>
     <div class="ap">Text overflow</div>
     <div class="notes">With the overflow-wrap property, we can linewrap longer words/strings:</div>
     <textarea name="" id="">
        <style>
  p {
    overflow-wrap: break-word;
    hyphens: auto;
    
    /* Prefix for Safari */
    -webkit-hyphens: auto;
  }
</style>
     </textarea>
     <div class="notes">
      Handling long unbreakable words/URLs

If no soft wrap opportunities exist, text can overflow.

Fix with overflow-wrap: break-word (or word-wrap in IE).

Hyphenation

hyphens: auto allows breaking words with hyphens.

Works best with overflow-wrap: break-word.

Requires <html lang="...">. Behavior varies by browser.

Ellipsis for overflow

text-overflow: ellipsis + overflow: hidden can truncate text with “…”.

Single-line ellipsis requires white-space: nowrap.

Multi-line ellipsis can be done with -webkit-line-clamp, though setup is verbose and buggy with flex/grid unless wrapped.

Best practices & cautions

Ellipsis should be used carefully (don’t hide critical info).

Hyphenation and truncation improve readability but depend on browser support.

Always balance usability and design when concealing text.

     </div>
        </div>
<div class="ap">Print style layout</div>
<div class="notes">
  .wrapper {
  column-count: 2;
  column-gap: 150px;
  max-width: 64rem;
  margin: 32px auto;
  border: 2px solid hsl(35deg 10% 40%);
  padding: 50px;
  background: linear-gradient(
    to right,
    hsl(35deg, 30%, 90%),
    hsl(35deg, 30%, 90%) 47%,
    hsl(35deg, 30%, 70%) 49.5%,
    hsl(35deg, 20%, 50%) 50%,
    hsl(35deg, 30%, 70%) 50.5%,
    hsl(35deg, 30%, 90%) 53%,
    hsl(35deg, 30%, 90%)
  );
}

h2 {
  font-size: 2rem;
  margin-bottom: 2em;
}

p {
  text-align: justify;
}

p:first-of-type::first-letter {
  font-size: 3em;
  float: left;
  line-height: 1em;
  margin-right: 0.2em;
}

p:not(:first-of-type) {
  text-indent: 2em;
}

* {
  font-family: 'Merriweather', serif;
}
</div>
<div class="notes">
  column layout
  break-inside: avoid; //prevents an element from being split across multiple columns, pages, or regions.
  column-count: 2; //specifies the number of columns an element should be divided into.
  column-gap: 150px; //specifies the gap between columns in a multi-column layout.
  list-style-type:none; //removes the default bullet points or numbering from list items.
  floats
  floats:left //The element is removed from the normal document flow and positioned to the left of its containing element. Other content will flow around it on the right side.
  Indentation
  <textarea name="" id="">
      p::first-letter {
    margin-left: 2rem;
  }
  p {
    text-indent: 2rem;
  }
  </textarea>
  Justified alignment
  <textarea name="" id="">
     p {
    text-align: justify;
    padding: 16px;
  }
  </textarea>\
  <div class="notes">
  p:first-of-type::first-letter {
  initial-letter: 2; /* Makes the first letter span 2 lines in height */
}
Explanation:
p:first-of-type → selects the first <p> inside a parent.

::first-letter → targets the very first letter of that paragraph.

initial-letter: 2; → asks the browser to render that first letter as a “drop cap” spanning 2 lines high

</div>
<div class="ap">Masonry Layout</div>
<div class="notes">
  in tobiath ahlin's blog, he mentioned that "Masonry layout is a grid layout based on columns, but unlike other grid layouts, it doesn’t have fixed height rows. Instead, the rows are determined by the height of the content within each column, creating a staggered, brick-like appearance."
  also, using order and nth -of-type pseudo class, we can create a masonry layout using flexbox.
</div>
<div class="ap">Text Styling</div>
<div class="notes">Line Length</div>
<textarea name="" id="">  max-width: 50ch; [for character per line]</textarea>
<div class="notes">Text alignment</div>
<textarea name="" id=""> text-align: justify; [for justified alignment]</textarea>
<div class="ap">Font stacks</div>
<div class="notes">font-family</div>
<textarea name="" id="">A rising trend in recent years is to use the "system font stack". This is a stack of fonts that default to the nicest default option for each platform.

It looks like this:

p {
  font-family:
    -apple-system, BlinkMacSystemFont, avenir next, avenir, segoe ui,
    helvetica neue, helvetica, Ubuntu, roboto, noto, arial, sans-serif;
}
or using font-variables
html {
  --font-sans-serif:
    -apple-system, BlinkMacSystemFont, avenir next, avenir, segoe ui,
    helvetica neue, helvetica, Ubuntu, roboto, noto, arial, sans-serif;
  --font-serif:
    Iowan Old Style, Apple Garamond, Baskerville, Times New Roman,
    Droid Serif, Times, Source Serif Pro, serif, Apple Color Emoji,
    Segoe UI Emoji, Segoe UI Symbol;

  /* Set a global default */
  font-family: var(--font-sans-serif);
}

/* Apply different fonts as needed */
p {
  font-family: var(--font-serif);
}
</textarea>
<div class="notes">Font Face 

</div>
<textarea name="" id="">When those @font-face statements are parsed by the browser, the font file declared under src will be fetched and loaded. 
  ChatGPT said:

If we try to use bold text without supplying a bold font file, the browser creates “faux” bold text by artificially thickening every line in the font, which often results in muddy and indistinct letters.
</textarea>
In order to understand this property, we need to talk about the font-display timeline.

The moment an HTML element tries to render text in our web font, a timer starts. Like a hockey game, there are 3 periods:

The block period. During this time, the text will be painted in an invisible ink, so that no text is visible. It'll render the font ASAP if it becomes available during this period.
The swap period. During this time, a fallback font is rendered (the first available font in the font stack). If the web font becomes available during this period, it gets swapped in immediately.
The failure period. If the font isn't loaded during the block or swap periods, it stops trying, and will keep showing the fallback font no matter what happens with the web font.
How long are each of these periods? It depends on the font-display property. Essentially, font-display is a way to control the length of each window.
    </div>
    </body>
    </html