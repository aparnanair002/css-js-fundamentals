<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Module 5</title>
    <link href="style.css" rel="stylesheet" />
  </head>
  <body>
    <div class="sidebar">
      <div class="module-item" id="mod1">
        <div class="module">
          <div class="sidebar-content">Home</div>
        </div>
      </div>
    </div>
    <div class="sidebody">
     <div class="ap">Text Rendering</div>
     <div class="notes">
        While comparing chrome and safari, it was found that Chrome tucks the commas closer to the preceding word than Safari.
         the reason that the letter placement is slightly different between browsers is that the browsers implement different <b>kerning algorithms.</b>
         Using CSS, we can opt to disable kerning altogether with font-kerning: none, but we aren't offered any fine-grained control. letter-spacing, the property that allows us to increase/decrease the space between individual characters, acts as a "kerning multiplier"
     <textarea name="" id=""> -webkit-font-smoothing property.

This property allows us to switch which aliasing algorithm the browser uses. But, tragically, it only works on macOS, and only in Chrome/Safari/Edge (not Firefox).</textarea>
     <div class="notes">WebKit is a browser rendering engine developed by Apple*</div>
     To summerize,
     <textarea name="" id="">
       <b> Kerning (character spacing)</b>

Chrome and Safari render text slightly differently.

Commas, letters, and spacing vary because each browser uses its own kerning algorithms.

Designers can tweak kerning manually with CSS (font-kerning: none + letter-spacing), but it’s tricky.

<b>Text rasterization & anti-aliasing</b>

Fonts are vectors, so browsers must “rasterize” them into pixels.

Anti-aliasing smooths edges, but each OS/browser has its own approach.

Windows uses subpixel rendering with colored edges (ClearType), macOS uses grayscale antialiasing.

<b>Font smoothing in CSS</b>

-webkit-font-smoothing (macOS only) lets you toggle antialiasing methods, but it’s limited.

Since macOS Mojave, Apple disabled subpixel antialiasing on Retina screens (too many tiny pixels, causes muddiness).

Firefox on macOS uses -moz-osx-font-smoothing, but it rarely makes a difference.

Windows browsers don’t expose smoothing controls via CSS.

<b>Accessibility debate</b>

Subpixel antialiasing was once considered crisper and better for readability (2012 article), but on modern high-DPI displays, grayscale antialiasing usually works better.

Browser rendering engines

Safari uses WebKit.

Chrome/Edge use Blink, a fork of WebKit.

That’s why many browsers still support -webkit- prefixed CSS.
     </textarea>
     <div class="ap">Text overflow</div>
     <div class="notes">With the overflow-wrap property, we can linewrap longer words/strings:</div>
     <textarea name="" id="">
        <style>
  p {
    overflow-wrap: break-word;
    hyphens: auto;
    
    /* Prefix for Safari */
    -webkit-hyphens: auto;
  }
</style>
     </textarea>
     <div class="notes">
      Handling long unbreakable words/URLs

If no soft wrap opportunities exist, text can overflow.

Fix with overflow-wrap: break-word (or word-wrap in IE).

Hyphenation

hyphens: auto allows breaking words with hyphens.

Works best with overflow-wrap: break-word.

Requires <html lang="...">. Behavior varies by browser.

Ellipsis for overflow

text-overflow: ellipsis + overflow: hidden can truncate text with “…”.

Single-line ellipsis requires white-space: nowrap.

Multi-line ellipsis can be done with -webkit-line-clamp, though setup is verbose and buggy with flex/grid unless wrapped.

Best practices & cautions

Ellipsis should be used carefully (don’t hide critical info).

Hyphenation and truncation improve readability but depend on browser support.

Always balance usability and design when concealing text.

     </div>
        </div>
<div class="ap">Print style layout</div>
<div class="notes">
  .wrapper {
  column-count: 2;
  column-gap: 150px;
  max-width: 64rem;
  margin: 32px auto;
  border: 2px solid hsl(35deg 10% 40%);
  padding: 50px;
  background: linear-gradient(
    to right,
    hsl(35deg, 30%, 90%),
    hsl(35deg, 30%, 90%) 47%,
    hsl(35deg, 30%, 70%) 49.5%,
    hsl(35deg, 20%, 50%) 50%,
    hsl(35deg, 30%, 70%) 50.5%,
    hsl(35deg, 30%, 90%) 53%,
    hsl(35deg, 30%, 90%)
  );
}

h2 {
  font-size: 2rem;
  margin-bottom: 2em;
}

p {
  text-align: justify;
}

p:first-of-type::first-letter {
  font-size: 3em;
  float: left;
  line-height: 1em;
  margin-right: 0.2em;
}

p:not(:first-of-type) {
  text-indent: 2em;
}

* {
  font-family: 'Merriweather', serif;
}
</div>
<div class="notes">
  column layout
  break-inside: avoid; //prevents an element from being split across multiple columns, pages, or regions.
  column-count: 2; //specifies the number of columns an element should be divided into.
  column-gap: 150px; //specifies the gap between columns in a multi-column layout.
  list-style-type:none; //removes the default bullet points or numbering from list items.
  floats
  floats:left //The element is removed from the normal document flow and positioned to the left of its containing element. Other content will flow around it on the right side.
  Indentation
  <textarea name="" id="">
      p::first-letter {
    margin-left: 2rem;
  }
  p {
    text-indent: 2rem;
  }
  </textarea>
  Justified alignment
  <textarea name="" id="">
     p {
    text-align: justify;
    padding: 16px;
  }
  </textarea>\
  <div class="notes">
  p:first-of-type::first-letter {
  initial-letter: 2; /* Makes the first letter span 2 lines in height */
}
Explanation:
p:first-of-type → selects the first <p> inside a parent.

::first-letter → targets the very first letter of that paragraph.

initial-letter: 2; → asks the browser to render that first letter as a “drop cap” spanning 2 lines high

</div>
<div class="ap">Masonry Layout</div>
<div class="notes">
  in tobiath ahlin's blog, he mentioned that "Masonry layout is a grid layout based on columns, but unlike other grid layouts, it doesn’t have fixed height rows. Instead, the rows are determined by the height of the content within each column, creating a staggered, brick-like appearance."
  also, using order and nth -of-type pseudo class, we can create a masonry layout using flexbox.
</div>
<div class="ap">Text Styling</div>
<div class="notes">Line Length</div>
<textarea name="" id="">  max-width: 50ch; [for character per line]</textarea>
<div class="notes">Text alignment</div>
<textarea name="" id=""> text-align: justify; [for justified alignment]</textarea>
<div class="ap">Font stacks</div>
<div class="notes">font-family</div>
<textarea name="" id="">A rising trend in recent years is to use the "system font stack". This is a stack of fonts that default to the nicest default option for each platform.

It looks like this:

p {
  font-family:
    -apple-system, BlinkMacSystemFont, avenir next, avenir, segoe ui,
    helvetica neue, helvetica, Ubuntu, roboto, noto, arial, sans-serif;
}
or using font-variables
html {
  --font-sans-serif:
    -apple-system, BlinkMacSystemFont, avenir next, avenir, segoe ui,
    helvetica neue, helvetica, Ubuntu, roboto, noto, arial, sans-serif;
  --font-serif:
    Iowan Old Style, Apple Garamond, Baskerville, Times New Roman,
    Droid Serif, Times, Source Serif Pro, serif, Apple Color Emoji,
    Segoe UI Emoji, Segoe UI Symbol;

  /* Set a global default */
  font-family: var(--font-sans-serif);
}

/* Apply different fonts as needed */
p {
  font-family: var(--font-serif);
}
</textarea>
<div class="notes">Font Face 

</div>
<textarea name="" id="">When those @font-face statements are parsed by the browser, the font file declared under src will be fetched and loaded. 
  ChatGPT said:

If we try to use bold text without supplying a bold font file, the browser creates “faux” bold text by artificially thickening every line in the font, which often results in muddy and indistinct letters.
</textarea>
In order to understand this property, we need to talk about the font-display timeline.

The moment an HTML element tries to render text in our web font, a timer starts. Like a hockey game, there are 3 periods:

The block period. During this time, the text will be painted in an invisible ink, so that no text is visible. It'll render the font ASAP if it becomes available during this period.
The swap period. During this time, a fallback font is rendered (the first available font in the font stack). If the web font becomes available during this period, it gets swapped in immediately.
The failure period. If the font isn't loaded during the block or swap periods, it stops trying, and will keep showing the fallback font no matter what happens with the web font.
How long are each of these periods? It depends on the font-display property. Essentially, font-display is a way to control the length of each window.
    </div>
    <div class="ap">Font Loading UX</div>
    <div class="notes">When using font-display: swap, text often switches from a fallback font to the final web font, causing layout shifts if the fonts differ in size or shape. To reduce this, browsers introduced font descriptors (f-mods) — properties like size-adjust, ascent-override, and descent-override that let developers adjust fallback fonts to better match the web font’s proportions.

Tools such as Fallback Font Generator, Fontaine, and next/font (for Next.js) help calculate these values automatically. Developers have found that tweaking these settings—like pairing Verdana with Wotfard—greatly reduces visual jumps.

While f-mods aren’t yet supported in Safari, they’re safe to use and improve the text rendering experience in Chrome, Firefox, and Edge.</div>
  <div class="ap">Icons</div> 
  <div class="notes">SVG (Scalable Vector Graphic) is an XML-based image format that defines images using shapes and paths instead of pixels — making it infinitely scalable without losing quality.</div>
<div class="ap">Images</div>
<div class="notes">Alt text should not include additional contextual information. For example, here's what you shouldn't do:

<div>
  <textarea name="" id=""><img
  src="/landscape.jpg"
  alt="Painting of a beautiful landscape. Artist: C. Essess"
/>
Instead, the attribution should go in a <figcaption> below the image:

<figure>
  <img
    src="/landscape.jpg"
    alt="Painting of a beautiful landscape."
  />
  <figcaption>
    Artist: C. Essess
  </figcaption>
</figure></textarea>
<div class="notes">Fit and position</div>
<textarea name="" id="">
  object-fit: cover; //The image will cover the entire container, cropping if necessary, while maintaining its aspect ratio.
  object-fit: contain; //The image will be scaled to fit within the container without cropping, maintaining its aspect ratio. There may be empty space if the aspect ratios differ.
  object-position: center; //Centers the image within its container.
  object-position: top; //Aligns the image to the top of its container.
  </textarea>
  <div class="notes">Images and flexbox</div>

  <textarea name="" id="">
      main{
    display:flex;
    flex-wrap:wrap;
  }
  .wrapper,.reviews{
    flex:1;
  }
  .wrapper img{
    min-width:360px;
    width:100%;
  }
  </textarea>
  <div class="notes">
    tried out a similar layout with another and found this
  </div>
  <textarea name="" id="">
    img{
  aspect-ratio:1/1;
  object-fit: cover;
  width:100%;
}
section{
  display:flex;
  gap:10px;
  flex-wrap:wrap;
}
.wrap{
 width:32% ;
  flex:1;
 min-width:100px;
}</textarea>
<div class="notes">Aspect ratio</div>
<textarea name="" id="">
  aspect-ratio: 16/9; //Sets a fixed aspect ratio of 16:9 for the element.
  aspect-ratio: 1/1; //Sets a square aspect ratio (1:1) for the element.
  aspect-ratio: auto; //Allows the element to maintain its intrinsic aspect ratio based on its content or image dimensions.
  
@supports is known as a feature query. It works just like a media query, but instead of targeting specific window sizes, it targets support for specific CSS declarations. We'll learn more about feature queries in the next module
  </textarea>
  <div class="notes">Reesponsive images</div>
  <textarea name="" id="">
    srcset → Simpler, great for basic responsive images.

<picture> → Needed for multiple formats or complex setups.

Generating many image variants can be tedious; tools like Next/Image or Gatsby-Image automate this.
</picture> is more flexible, allowing different images for various conditions (like art direction changes), while srcset is simpler for basic responsive needs.
  </textarea>
  <div class="notes">Background images</div>
  <textarea name="" id="">
    Background Images (Summary)
1. When to Use

<img> tags can’t tile images, so for repeating patterns, we use CSS background images.

Example:

body {
  background-image: url('pattern.png');
}


By default, the image appears at its native size and tiles automatically.

2. Handling High-DPI Screens

High-DPI displays make normal images look blurry.
To fix this, use media queries with the min-resolution feature:

@media (min-resolution: 2dppx) {
  body { background-image: url('pattern@2x.png'); }
}
@media (min-resolution: 3dppx) {
  body { background-image: url('pattern@3x.png'); }
}


Add a fallback -webkit-min-device-pixel-ratio for older Safari versions.

Set background-size equal to the 1x image size to keep scaling correct.

3. Fit and Positioning

background-size controls how the image fits:

cover — fills the entire area (like object-fit: cover).

contain — scales to fit inside the element.

background-position works like object-position, controlling placement.

4. Background Repeat Options

By default, images tile (repeat) both horizontally and vertically.
Other options:

repeat — default tiling.

round — scales images so they fit evenly, no cut-off edges.

space — adds gaps between tiles, keeping original size.

5. Generative (CSS) Backgrounds

background-image can also use gradients, not just URLs.

CSS-only background patterns can be created using gradient tricks.
👉 Example resource: Magic Pattern (pure CSS geometric patterns).
  </textarea>
</div>
</div>
</body>
    </html