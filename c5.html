<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Higher-Order Functions</title>
  <link rel="stylesheet" href="styles.css" />
</head>
<body>

  <div class="sidebar">
    <h2>Contents</h2>
    <ul>
      <a href="./c1.html"><div class="gridded">Chap 1</div></a>
      <a href="./c2.html"><div class="gridded">Chap 2</div></a>
      <a href="./c3.html"><div class="gridded">Chap 3</div></a>
      <a href="./c4.html"> <div class="gridded">Chap 4</div></a>
      <a href="./c5.html"><div class="gridded">Chap 5</div></a>
      <a href="./c6.html"> <div class="gridded">Chap 6</div></a>
      <a href="./c7.html"><div class="gridded">Chap 7</div></a>
      <a href="./c8.html"><div class="gridded">Chap 8</div></a>
      <a href="./c9.html"><div class="gridded">Chap 9</div></a>
      <a href="./c10.html"><div class="gridded">Chap 10</div></a>
    </ul>
  </div>

  <div class="container">
    <h1>Higher-Order Functions</h1>

    <blockquote>
      “There are two ways of constructing a software design: One way is to make it so simple that there are obviously no deficiencies,
      and the other way is to make it so complicated that there are no obvious deficiencies.”  
      — C.A.R. Hoare, 1980 ACM Turing Award Lecture
    </blockquote>

    <p>
      Large programs increase complexity, confusion, bugs, and debugging effort.
      Smaller, abstracted programs express solutions closer to the intent of the problem — easier to reason and less error-prone.
    </p>

    <h2>Abstraction</h2>
    <p>
      Abstractions allow programmers to work at a higher conceptual level by hiding irrelevant details.
      Functions help us build these abstractions.
    </p>

    <h2>Abstracting Repetition</h2>
    <p>You can write a loop directly:</p>
    <pre><code>for (let i = 0; i &lt; 10; i++) {
  console.log(i);
}</code></pre>

    <p>But we can abstract the idea of “repeat something N times” into a function:</p>

    <pre><code>function repeat(n, action) {
  for (let i = 0; i &lt; n; i++) {
    action(i);
  }
}

repeat(3, console.log);</code></pre>

    <p>
      We can pass a predefined function or create one inline:
    </p>

    <pre><code>let labels = [];
repeat(5, i =&gt; labels.push(`Unit ${i+1}`));</code></pre>

    <h2>Higher-Order Functions</h2>
    <p>
      Functions that receive or return other functions are called higher-order functions.
      They allow abstraction over actions, not just values.
    </p>

    <h3>Functions that Create Functions</h3>
    <pre><code>function greaterThan(n) {
  return m =&gt; m &gt; n; //n doesnt change, m is the argument
}

let greaterThan10 = greaterThan(10);
console.log(greaterThan10(11)); // true</code></pre>

    <h3>Functions that Modify Functions</h3>
    <pre><code>function noisy(f) {
  return (...args) =&gt; {
    console.log("calling with", args);
    let result = f(...args);
    console.log("called with", args, ", returned", result);
    return result;
  };
}

noisy(Math.min)(3,2,1);</code></pre>

    <h3>Control Flow Functions</h3>
    <pre><code>function unless(test, then) {
  if (!test) then();
}</code></pre>

    <h2>Built-in Higher-Order Methods</h2>
    <p>Example: <b>forEach</b></p>
    <pre><code>["A","B"].forEach(l =&gt; console.log(l));</code></pre>

    <h2>Data Processing — Script Dataset</h2>
    <p>
      Unicode defines ~140 writing scripts. Example dataset entries look like:
    </p>
    <pre><code>{
  name: "Coptic",
  ranges: [[994, 1008], ...],
  direction: "ltr",
  year: -200,
  living: false
}</code></pre>

    <h2>Array Transformations</h2>

    <h3>Filtering</h3>
    <pre><code>console.log(SCRIPTS.filter(s =&gt; s.living));</code></pre>

    <h3>Mapping</h3>
    <pre><code>let rtlScripts = SCRIPTS.filter(s =&gt; s.direction == "rtl");
console.log(rtlScripts.map(s =&gt; s.name));</code></pre>

    <h3>Reducing</h3>
    <pre><code>console.log([1,2,3,4].reduce((a,b) =&gt; a + b));</code></pre>

    <p>Example — finding script with most characters:</p>
    <pre><code>function characterCount(script) {
  return script.ranges.reduce((count,[from,to]) =&gt; count + (to - from), 0);
}

console.log(SCRIPTS.reduce((a,b) =&gt;
  characterCount(a) &lt; characterCount(b) ? b : a));</code></pre>

    <h2>Function Composition</h2>
    <pre><code>function average(array){
  return array.reduce((a,b) =&gt; a + b) / array.length;
}

console.log(Math.round(average(
  SCRIPTS.filter(s =&gt; s.living).map(s =&gt; s.year))));</code></pre>

    <h2>Character Scripts</h2>
    <pre><code>function characterScript(code){
  for (let script of SCRIPTS){
    if (script.ranges.some(([from,to]) =&gt; code &gt;= from && code &lt; to))
      return script;
  }
  return null;
}</code></pre>

    <h2>Extracting Script Use</h2>
    <pre><code>function countBy(items, groupName) {
  ...
}</code></pre>

    <pre><code>function textScripts(text) {
  let scripts = countBy(text, char =&gt; {
    let script = characterScript(char.codePointAt(0));
    return script ? script.name : "none";
  }).filter(({name}) =&gt; name != "none");

  let total = scripts.reduce((n, {count}) =&gt; n + count, 0);
  if (total == 0) return "No scripts found";

  return scripts.map(({name,count}) =&gt;
    `${Math.round(count * 100 / total)}% ${name}`
  ).join(", ");
}</code></pre>

    <h2>Summary</h2>
    <ul>
      <li>You can pass functions as values.</li>
      <li>Higher-order functions fill “gaps” in computation.</li>
      <li>Array methods like forEach, filter, map, reduce, find, and some help transform data.</li>
    </ul>

    <h2>Exercises</h2>

    <h3>Flattening</h3>
    <pre><code>let arrays = [[1, 2, 3], [4, 5], [6]];
console.log(arrays.reduce((a, b) =&gt; a.concat(b))); 
// → [1,2,3,4,5,6]</code></pre>

    <h3>Your Own Loop</h3>
    <pre><code>
      function loop(value, test, update, body) {
  for (let current = value; test(current); current = update(current)) {
    body(current);
  }
}
loop(3, n =&gt; n &gt; 0, n =&gt; n - 1, console.log);</code></pre>

    <h3>Everything</h3>
    <pre><code>
function every(array, test) {
  return !array.some(element => !test(element));
}
//OR
function every(array, test) {
  for (let element of array) {
    if (!test(element)) {
      return false;
    }
  }
  return true;
}
</code></pre>

    <h3>Dominant Writing Direction</h3>
    <pre><code>function dominantDirection(text){
function dominantDirection(text) {
  // Count characters by script direction
  let counted = countBy(text, char => {
    let script = characterScript(char.codePointAt(0));
    return script ? script.direction : "none";
  }).filter(({name}) => name != "none");

  // If no script found, return default or message
  if (counted.length === 0) return "ltr";

  // Find the direction with the highest count
  return counted.reduce((a, b) => (a.count > b.count ? a : b)).name;
}

console.log(textScripts('英国的狗说"woof", 俄罗斯的狗说"тяв"'));
// → 61% Han, 22% Latin, 17% Cyrillic
}</code></pre>
Property	Description
name	Name of the script (e.g., "Latin", "Cyrillic", "Han")
ranges	Array of Unicode ranges that belong to this script. Each range is [from, to] (numbers).
direction	Writing direction: "ltr", "rtl", or "ttb"
year	Approximate year the script was first used (historical info)
living	Boolean: whether the script is still in use today
link	URL to more information about the script (optional, sometimes included in Eloquent JS dataset)
  </div>
</body>
</html>
