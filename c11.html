<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Asynchronous Programming – Summary</title>
    <link rel="stylesheet" href="styles.css" />
</head>
<body>
  <div class="sidebar">
  <h2>Contents</h2>
  <ul>
      <a href="./c1.html"><div class="gridded">Chap 1</div></a>
      <a href="./c2.html"><div class="gridded">Chap 2</div></a>
       <a href="./c3.html"><div class="gridded">Chap 3</div></a>
      <a href="./c4.html"> <div class="gridded">Chap 4</div></a>
       <a href="./c5.html"><div class="gridded">Chap 5</div></a>
         <a href="./c6.html"> <div class="gridded">Chap 6</div></a>
       <a href="./c7.html"><div class="gridded">Chap 7</div></a>
       <a href="./cc8.html"><div class="gridded">Chap 8</div></a>
              <a href="./c9.html"><div class="gridded">Chap 9</div></a>
        <a href="./c10.html"><div class="gridded">Chap 10</div></a>
        <a href="./c11.html"><div class="gridded">Chap 11</div></a>
                <a href="./c12.html"><div class="gridded">Chap 12</div></a>
      <a href="./c13.html"><div class="gridded">Chap 13</div></a>
        <a href="./c14.html"><div class="gridded">Chap 14</div></a>
          <a href="./c15.html"><div class="gridded">Chap 15</div></a>

          <a href="./c17.html"><div class="gridded">Chap 17</div></a>
          <a href="./c18.html"><div class="gridded">Chap 18</div></a>
          <a href="./c20.html"><div class="gridded">Chap 20</div></a>





    </ul>
  </div>
  <h1>Asynchronous Programming – Quick Summary</h1>

  <section>
    <h2>What Is Asynchronous Programming?</h2>
    <ul>
      <li>Allows programs to continue running while waiting for slow operations (network, disk, timers).</li>
      <li>Prevents the processor from sitting idle.</li>
      <li>Common in JavaScript environments (Browser & Node.js).</li>
    </ul>
  </section>

  <section>
    <h2>Synchronous vs Asynchronous</h2>
    <ul>
      <li><strong>Synchronous:</strong> Tasks run one after another; waiting blocks execution.</li>
      <li><strong>Asynchronous:</strong> Long-running tasks run in the background; program continues.</li>
      <li>Waiting is <em>implicit</em> in synchronous code and <em>explicit</em> in asynchronous code.</li>
    </ul>
  </section>

  <section>
    <h2>Callbacks</h2>
    <ul>
      <li>Functions passed as arguments to run after an async task completes.</li>
      <li>Example: <code>setTimeout(fn, time)</code></li>
      <li>Problems:
        <ul>
          <li>Deep nesting (callback hell).</li>
          <li>Error handling is difficult.</li>
          <li>Asynchronicity spreads through the code.</li>
        </ul>
      </li>
    </ul>
  </section>

  <section>
    <h2>Promises</h2>
    <ul>
      <li>A Promise represents a value that may be available in the future.</li>
      <li>States: <strong>pending</strong>, <strong>fulfilled</strong>, <strong>rejected</strong>.</li>
      <li>Key methods:
        <ul>
          <li><code>then()</code> – handle success</li>
          <li><code>catch()</code> – handle failure</li>
          <li><code>Promise.resolve()</code></li>
          <li><code>Promise.reject()</code></li>
          <li><code>Promise.all()</code> – wait for multiple promises</li>
        </ul>
      </li>
      <li>Promises allow chaining and cleaner async flow.</li>
    </ul>
  </section>

  <section>
    <h2>Error Handling with Promises</h2>
    <ul>
      <li>Errors propagate automatically through promise chains.</li>
      <li>If any step fails, the chain becomes rejected.</li>
      <li><code>catch()</code> can recover from failures.</li>
    </ul>
    <div class="note">
      Rejected promises that are not handled are reported as errors by JavaScript runtimes.
    </div>
  </section>

  <section>
    <h2>Async / Await</h2>
    <ul>
      <li><code>async</code> functions always return a promise.</li>
      <li><code>await</code> pauses execution until a promise resolves or rejects.</li>
      <li>Makes asynchronous code look synchronous.</li>
      <li>Improves readability over chained <code>then()</code> calls.</li>
    </ul>
  </section>

  <section>
    <h2>Generators</h2>
    <ul>
      <li>Defined using <code>function*</code> and <code>yield</code>.</li>
      <li>Can pause and resume execution.</li>
      <li>Useful for building iterators.</li>
      <li><code>async</code> functions are a special kind of generator using promises.</li>
    </ul>
  </section>

  <section>
    <h2>Promise.all()</h2>
    <ul>
      <li>Runs multiple promises in parallel.</li>
      <li>Resolves when all promises succeed.</li>
      <li>Rejects immediately if any promise fails.</li>
      <li>Useful for parallel network or file operations.</li>
    </ul>
  </section>

  <section>
    <h2>The Event Loop</h2>
    <ul>
      <li>JavaScript runs on a single thread.</li>
      <li>Async callbacks are queued and executed one at a time.</li>
      <li>Long-running code blocks other events.</li>
      <li>Promises always resolve in a future event loop turn.</li>
    </ul>
  </section>

  <section>
    <h2>Common Asynchronous Bugs</h2>
    <ul>
      <li>Shared state modified across async gaps.</li>
      <li>Race conditions due to timing differences.</li>
      <li>Fix by:
        <ul>
          <li>Returning values instead of mutating variables.</li>
          <li>Using <code>Promise.all()</code> and pure functions.</li>
        </ul>
      </li>
    </ul>
  </section>

  <section>
    <h2>Key Takeaways</h2>
    <ul>
      <li>Asynchronous programming prevents blocking.</li>
      <li>Callbacks → Promises → Async/Await is the evolution.</li>
      <li>Promises simplify error handling and composition.</li>
      <li>Async/Await offers the cleanest syntax.</li>
      <li>Understanding the event loop is critical.</li>
    </ul>
  </section>

</body>
</html>
