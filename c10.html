<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Modules — Summary</title>
  <link rel="stylesheet" href="styles.css" />
</head>
<body>

<div class="sidebar">
  <h2>Contents</h2>
  <ul>
      <a href="./c1.html"><div class="gridded">Chap 1</div></a>
      <a href="./c2.html"><div class="gridded">Chap 2</div></a>
       <a href="./c3.html"><div class="gridded">Chap 3</div></a>
      <a href="./c4.html"> <div class="gridded">Chap 4</div></a>
       <a href="./c5.html"><div class="gridded">Chap 5</div></a>
         <a href="./c6.html"> <div class="gridded">Chap 6</div></a>
       <a href="./c7.html"><div class="gridded">Chap 7</div></a>
       <a href="./cc8.html"><div class="gridded">Chap 8</div></a>
              <a href="./c9.html"><div class="gridded">Chap 9</div></a>
        <a href="./c10.html"><div class="gridded">Chap 10</div></a>
        <a href="./c11.html"><div class="gridded">Chap 11</div></a>
                <a href="./c12.html"><div class="gridded">Chap 12</div></a>


    </ul>
</div>

<h1>Modules — Summary</h1>

<h2>1. Why Modules?</h2>
<p>
  Modules help break code into <b>small, independent, reusable</b> pieces.
  They reduce complexity and allow composition of systems rather than
  building everything in one giant file.
</p>

<h2>2. Cohesion & Decoupling</h2>
<p>
  Good modules group related functionality and minimize
  unnecessary connections between components.
</p>

<h2>3. Browser Scripts Are Global by Default</h2>
<p>
  Without modules, each script shares a global namespace:
</p>
<pre><code>&lt;script src="1.js"&gt;&lt;/script&gt;
&lt;script src="2.js"&gt;&lt;/script&gt;
</code></pre>

<p><b>Problem:</b> name collisions and hidden dependencies.</p>

<h2>4. Functions Create Local Scope</h2>
<p>
  Wrapping code in functions isolates it from globals:
</p>
<pre><code>(function() {
  function f() { ... }
  ...
})();
</code></pre>

<h2>5. Objects as Modules</h2>
<p>
  A module can return an object with only selected properties exposed.
</p>

<h2>6. Evaluating Code from Files</h2>
<p>
  Web browsers load scripts.
  Node's <code>require</code> allows reading and executing files:
</p>
<pre><code>const require = require("readFile");
</code></pre>

<h2>7. CommonJS Modules</h2>
<p>
  Node uses CommonJS with <code>require()</code> and <code>module.exports</code>.
</p>

<pre><code>// exporting
exports.sum = (a,b) => a + b;

// importing
const { sum } = require("./mod");
</code></pre>

<h2>8. Dependencies</h2>
<p>
  Modules can depend on other modules, creating a dependency graph.
</p>

<h2>9. Package Structure</h2>
<p>
  A package bundles multiple modules, config files,
  documentation, and sometimes testing code.
</p>

<pre><code>package-name/
 ┣ index.js
 ┣ README.md
 ┗ package.json
</code></pre>

<h2>10. ES Modules (ESM)</h2>
<p>
  Modern JavaScript uses <code>import</code> and <code>export</code>.
</p>

<pre><code>export function sum(a,b){ ... }
import { sum } from "./sum.js";
</code></pre>

<p><b>Benefits:</b> statically analyzable, supports bundling, optimized loading.</p>

<h2>11. Module Design Principles</h2>
<p>
  - Small surface area<br>
  - Internal details hidden<br>
  - Only expose what’s needed<br>
  - Avoid tight coupling
</p>

<h2>12. Summary</h2>
<p>
  
<b>Why modules matter:</b><br>
As programs grow, they often become tangled and hard to understand—sometimes called a <i>“big ball of mud.”</i>
Modules help avoid this by breaking programs into clear, independent pieces with well-defined roles.<br><br>

<b>What a module is:</b><br>
A module is a self-contained unit of code that:<br>
- Exports an interface (what other modules can use)<br>
- Declares dependencies (what it needs from other modules)<br><br>

<b>Benefits of modular design:</b><br>
- Easier to understand and maintain<br>
- Easier to reuse code in other programs<br>
- Less accidental interference between parts of the program<br>
- More LEGO-like structure, less mud-like entanglement<br><br>

<hr><br>

<h3>ES Modules (Modern JavaScript)</h3><br>

- Introduced in <b>ES2015</b><br>
- Use <code>export</code> and <code>import</code><br>
- Each module has its <b>own scope</b><br>
- Imports are resolved <b>before execution</b><br>
- Supports:<br>
&nbsp;&nbsp;• Named exports/imports<br>
&nbsp;&nbsp;• Renaming imports using <code>as</code><br>
&nbsp;&nbsp;• Default exports<br>
&nbsp;&nbsp;• Importing everything as an object<br><br>

<hr><br>

<h3>Packages & NPM</h3><br>

- A <b>package</b> is reusable, distributable code (often multiple modules)<br>
- <b>NPM</b> provides:<br>
&nbsp;&nbsp;• An online package registry<br>
&nbsp;&nbsp;• Tools to install and manage dependencies<br>
- Packages prevent code duplication and reinvention<br>
- Most packages are open-source but have licenses that must be respected<br><br>

<hr><br>

<h3>CommonJS Modules (Older System)</h3><br>

- Used before ES modules, still common in Node.js<br>
- Uses:<br>
&nbsp;&nbsp;• <code>require()</code> to import modules<br>
&nbsp;&nbsp;• <code>exports</code> to define the interface<br>
- Modules are loaded <b>at runtime</b><br>
- Allows limited <b>circular dependencies</b><br>
- Not recommended for new projects, but still widely encountered<br><br>

<hr><br>

<h3>Bundling & Building</h3><br>

- JavaScript code often goes through:<br>
&nbsp;&nbsp;• Compilation (TypeScript → JavaScript)<br>
&nbsp;&nbsp;• Bundling (many files → one file)<br>
&nbsp;&nbsp;• Minification (smaller, faster code)<br>
- These steps improve performance, especially for web applications<br><br>

<hr><br>

<h3>Good Module Design Principles</h3><br>

- Keep interfaces <b>simple and predictable</b><br>
- Do <b>one focused job</b><br>
- Prefer <b>functions over stateful objects</b><br>
- Use <b>simple data structures</b> when possible<br>
- Design for <b>composition</b> with other code<br>
- Follow common conventions to improve reuse<br><br>

<hr><br>

<h3>Key Takeaway</h3><br>

Modules provide structure, clarity, and reusability.<br>
Well-designed modules make programs easier to understand today—and much easier to maintain tomorrow.<br>


</body>
</html>
